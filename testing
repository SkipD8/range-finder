<!DOCTYPE html>
<html>
<head>
  <title>Range Finder</title>
  <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #map {
      height: 100%;
      width: 100%;
      touch-action: none; /* allow custom gestures */
    }
    #clearBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: transparent;
      color: #fff;
      font-family: 'Varela Round', sans-serif;
      font-size: calc(16.6vw);
      font-weight: 900;
      border: none;
      cursor: pointer;
      display: none;
      line-height: 1;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <button id="clearBtn">X</button>

  <script>
    let map;
    let userMarker;
    let userLocation;
    let watchId;
    let pointMarkers = [];
    let lines = [];
    let endDots = [];
    let labels = [];
    let startAngle = null;
    let startHeading = 0;

    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 18,
        mapTypeId: 'satellite',
        tilt: 0,
        rotateControl: false,
        fullscreenControl: false,
        streetViewControl: false,
        mapTypeControl: false
      });

      map.addListener('tilt_changed', () => {
        if (map.getTilt() !== 0) {
          map.setTilt(0);
        }
      });

      if (navigator.geolocation) {
        watchId = navigator.geolocation.watchPosition(position => {
          userLocation = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
          };

          if (userMarker) {
            userMarker.setPosition(userLocation);
          } else {
            userMarker = new google.maps.Marker({
              position: userLocation,
              map: map,
              title: "You are here",
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 14,
                fillColor: '#4285F4',
                fillOpacity: 1,
                strokeWeight: 3,
                strokeColor: '#FFFFFF'
              }
            });
            map.setCenter(userLocation);
          }

        }, (error) => {
          alert("Geolocation error:\n" + error.message + "\n(Code " + error.code + ")");
        }, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 2000
        });
      } else {
        alert("Geolocation not supported.");
      }

      map.addListener("click", (e) => {
        if (pointMarkers.length === 0) {
          if (!userLocation) return;

          if (watchId) {
            navigator.geolocation.clearWatch(watchId);
          }

          addPointMarker(userLocation);
          addPointMarker(e.latLng.toJSON());
          redraw();
          document.getElementById("clearBtn").style.display = "block";
        }
      });

      map.addListener("dblclick", (e) => {
        if (pointMarkers.length >= 1) {
          addPointMarker(e.latLng.toJSON());
          redraw();
        }
      });

      document.getElementById("clearBtn").addEventListener("click", () => {
        pointMarkers.forEach(m => m.setMap(null));
        lines.forEach(l => l.setMap(null));
        endDots.forEach(d => d.setMap(null));
        labels.forEach(lbl => lbl.setMap(null));
        pointMarkers = [];
        lines = [];
        endDots = [];
        labels = [];
        document.getElementById("clearBtn").style.display = "none";

        map.setHeading(0);

        if (navigator.geolocation) {
          watchId = navigator.geolocation.watchPosition(position => {
            userLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };
            if (userMarker) {
              userMarker.setPosition(userLocation);
            } else {
              userMarker = new google.maps.Marker({
                position: userLocation,
                map: map,
                title: "You are here",
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 14,
                  fillColor: '#4285F4',
                  fillOpacity: 1,
                  strokeWeight: 3,
                  strokeColor: '#FFFFFF'
                }
              });
              map.setCenter(userLocation);
            }
          });
        }
      });

      setupRotationGesture();
    }

    function addPointMarker(position) {
      const marker = new google.maps.Marker({
        position: position,
        map: map,
        draggable: true,
        optimized: false,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 32, // bigger invisible hit zone
          fillColor: '#FFFFFF',
          fillOpacity: 1.0,
          strokeWeight: 0
        }
      });

      marker.addListener('drag', () => {
        redraw();
      });

      marker.addListener('dragend', () => {
        redraw();
      });

      pointMarkers.push(marker);
    }

    function redraw() {
      lines.forEach(line => line.setMap(null));
      endDots.forEach(dot => dot.setMap(null));
      labels.forEach(lbl => lbl.setMap(null));
      lines = [];
      endDots = [];
      labels = [];

      for (let i = 0; i < pointMarkers.length - 1; i++) {
        const from = pointMarkers[i].getPosition().toJSON();
        const to = pointMarkers[i + 1].getPosition().toJSON();
        drawLine(from, to);
        addEndDot(to);
        addLabel(from, to);
      }
    }

    function drawLine(from, to) {
      const line = new google.maps.Polyline({
        path: [from, to],
        geodesic: true,
        strokeColor: "#FFFFFF",
        strokeOpacity: 1.0,
        strokeWeight: 10,
        map: map
      });
      lines.push(line);
    }

    function addEndDot(position) {
      const dot = new google.maps.Marker({
        position: position,
        map: map,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 14,
          fillColor: '#FFFFFF',
          fillOpacity: 1,
          strokeWeight: 0
        }
      });
      endDots.push(dot);
    }

    function addLabel(from, to) {
      const distanceYards = calculateDistance(from, to);

      const midLat = (from.lat + to.lat) / 2;
      const midLng = (from.lng + to.lng) / 2;

      const dx = to.lng - from.lng;
      const dy = to.lat - from.lat;
      const length = Math.sqrt(dx * dx + dy * dy);

      const offsetFactor = 0.0003;
      const offsetLng = -dy / length * offsetFactor;
      const offsetLat = dx / length * offsetFactor;

      const offsetMidpoint = {
        lat: midLat + offsetLat,
        lng: midLng + offsetLng
      };

      const label = new google.maps.Marker({
        position: offsetMidpoint,
        map: map,
        icon: {
          path: 'M0 0',
          scale: 0
        },
        label: {
          text: `${distanceYards.toFixed(0)}y`,
          fontSize: "36px",
          fontWeight: "bold",
          fontFamily: "Varela Round",
          color: "#FFFFFF"
        }
      });

      labels.push(label);
    }

    function calculateDistance(from, to) {
      const R = 6371000;
      const rad = Math.PI / 180;
      const lat1 = from.lat * rad;
      const lat2 = to.lat * rad;
      const dLat = (to.lat - from.lat) * rad;
      const dLon = (to.lng - from.lng) * rad;

      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distanceMeters = R * c;
      return distanceMeters * 1.09361;
    }

    function setupRotationGesture() {
      const container = document.getElementById("map");

      container.addEventListener("touchstart", (e) => {
        if (e.touches.length === 2) {
          startAngle = getAngle(e.touches[0], e.touches[1]);
          startHeading = map.getHeading() || 0;
        }
      });

      container.addEventListener("touchmove", (e) => {
        if (e.touches.length === 2 && startAngle !== null) {
          const currentAngle = getAngle(e.touches[0], e.touches[1]);
          const delta = currentAngle - startAngle;
          map.setHeading(startHeading + delta);
        }
      });

      container.addEventListener("touchend", (e) => {
        if (e.touches.length < 2) {
          startAngle = null;
        }
      });
    }

    function getAngle(p1, p2) {
      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * (180 / Math.PI);
    }
  </script>
  <script async
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD4LJH9tkxLT91PO31BM6y2p2N_KRE2fdk&callback=initMap">
  </script>
</body>
</html>
